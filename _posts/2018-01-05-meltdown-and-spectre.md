---
layout: post
title:  "Meltdown and Spectre"
short_title: 'Критическая уязвимость процессоров'
date:   2018-01-05 04:40:00
comments: true
tags: [infosec]
---

Чем грозит и как работает недавно обнародованная уязвимость в процессорах.

> **TL;DR:**![](/images/2018/meltdown-spectre/duck.jpg)![](/images/2018/meltdown-spectre/gandalf.jpg)

## Подводка(конвейер, спекулятивное исполнение, кэш)

### Конвейер

Итак, для того, чтоб понять, как работает уязвимости Meltdown и Spectre, надо для начала понять, как работает сам процессор. Современные процессоры используют вычислительный конвейер, чтобы выполнять программы быстрее. Программы состоят из инструкций, которые выполняются процессором последовательно и цикл выполнения каждой инструкции состоит из нескольких шагов, например:

* Прочитать инструкцию из памяти
* Исполнить инструкцию
* Записать результат в память и/или регистры

Современные же процессоры имеют несколько ядер и можно этот цикл для разных инструкций выполнять параллельно на нескольких ядрах: как только одно ядро прочитало инструкцию из памяти и начинает выполнять ее, другое ядро читает следующую инструкцию и дальше.

[![Общий четырёхуровневых конвейер; цветные квадраты символизируют независимые друг от друга инструкции. Источник-Wikipedia](/images/2018/meltdown-spectre/pipeline.png)](https://ru.wikipedia.org/wiki/Вычислительный_конвейер#/media/File:Pipeline,_4_stage.svg)

### Спекулятивное выполнение

Недостатком такого подхода являются случаи, когда последовательные инструкции не могут быть выполнены одновременно. Такие ситуации называются конфликтами и возникают если например в последующих инструкциях используются результаты выполнения текущей инструкции. В момент, когда происходит конфликт, некоторые ядра процессора вынуждены простаивать, пока конфликт не разрешится, что плачевно сказывается на производительности. Иной возможной причиной конфликта может являться условный переход и жта ситуация называется конфликтом по управлению. При условном переходе программа как бы ветвится в зависимости от какого-то условия и выполняется либо одна, либо другая последовательность инструкций. Такие конфликты не позволяют процессору параллельно выполнять последующие инструкции, пока не известен результат проверки условия.
![В результате проверки условия, программа выполняет либо одни, либо другие инструкции](/images/2018/meltdown-spectre/if.png)

Чтоб процессор не простаивал, придумана такая оптимизация, которая называется спекулятивным исполнением. Процессоры с данной технологией, не дожидаясь вычисления условия, начинают выполнение обеих ветвей программы, пока не станет известен результат вычисления условия. Как только результат становится известен, процессор продолжает выполнение той ветки, которая предполагается условием, а результаты другой ветки просто не учитывает.

### Кэш

Для работы процессор берет данные из оперативной памяти. Для ускорения доступа к данным в процессорах используется кэш. Кэш-это небольшая область памяти, находящаяся непосредственно в самом процессоре и доступ к ней в десятки раз быстрее, чем доступ к оперативной памяти. В кеш не получится поместить все данные из оперативной памяти, однако данные, нужные процессору, или данные, которые станут нужны позднее, загружаются в кеш, дабы ускорить доступ к этим данным и соответственно ускорить работу программы.

### Предсказатель переходов

Механизм в процессорах с конвейерной архитектурой, который заранее предсказывает результат выполнения условия в условных операторах и заранее загружает инструкции из оперативной памяти в кэш процессора, позволяя не ждать загрузки инструкций, когда они действительно понадобятся.

## Принципы работы уязвимости

Исследователи нашли три варианта уязвимости:

* Bounds check bypass ([CVE-2017-5753](https://vulners.com/search?query=CVE-2017-5753))
* Branch target injection ([CVE-2017-5715](https://vulners.com/search?query=CVE-2017-5715))
* Rogue data cache load ([CVE-2017-5754](https://vulners.com/search?query=CVE-2017-5754))


```c
if (x < array1_size)
    y = array2[array1[x] * 256];
```

Благодаря спекулятивному исполнению код будет выполняться так: сначала процессор попытается вычислить значение `x < array1_size`. Значения `array1_size` может не оказаться в кэше процессора и для лучшего использования ресурсов, процессор попытается исполнить `y = array2[array1[x] * 256];`, пока `array1_size` достается из относительно медленной оперативной памяти. Если же значение `x` больше, чем длина массива, то мы получаем доступ к данным за пределом массива. Конечно же процессор не даст просто так доступ к этим даным, ведь когда он поймет, что `x < array1_size` ложно, он откатит состояние на момент до `y = array2[array1[x] * 256];`. Однако, если `y = array2[array1[x] * 256];` успеет выполниться, то в кэш процессора попадет ячейка памяти по адресу `array2 + (array1[x] * 256);`. Теперь, если перебирать каждый байт после адреса `array2` и смотреть, как быстро процессор отдает значение, можно предположить, какая ячейка памяти лежит в кэше. А номер данной ячейки будет равен значению ячейки памяти `array1+x` помноженному на 256. Таким образом можно, перебирая, получать данные из памяти, находящейся в недоступной области для атакующего процесса.

Самым неприятным являет то, что таким образом JS может читать данные из памяти браузера, не предназначеные ему, что чревато кражей данных сайтами прямиком из браузера.

```javascript
if (index < simpleByteArray.length) {
  index = simpleByteArray[index | 0];
  index = (((index * TABLE1_STRIDE)|0) & (TABLE1_BYTES-1))|0;
  localJunk ^= probeTable[index|0]|0;
}
```

 Продожение следует...
